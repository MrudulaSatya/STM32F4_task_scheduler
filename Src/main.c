/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include <stdio.h>
#include "main.h"
#include "led.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif


//User tasks
void task1_handler(void);
void task2_handler(void);
void task3_handler(void);
void task4_handler(void);
void idle_task(void);
void init_systick_timer(uint32_t tick_hz); //Loads and starts systick timer
__attribute__((naked)) void init_sched_stack(uint32_t sched_top_of_stack_addr); //initialize MSP with the address of start of scheduler stack

void init_task_stack(void);

void enable_processor_faults(void);

uint32_t get_current_psp_value(void);
void update_psp_value_of_task(uint32_t current_psp_value);
void update_next_task(void);

__attribute__((naked)) void switch_sp_to_PSP(void);

void task_delay(uint32_t tick_count);
void update_global_tick_count();
void unblock_tasks();
void schedule_next_task();

typedef struct
{
	uint32_t psp_value;
	uint32_t block_count;
	uint8_t state;
	void  (*task_handler)(void);

} TCB_t;

/** Global Variables **/

TCB_t user_tasks[MAX_TASKS]; // Updated in the handler and in the user tasks

uint8_t current_task = 1; // initialized to task 1 // Updated only in Handler mode
uint32_t g_tick_count = 0; //global tick count // Updated only in Handler mode

int main(void)
{
	//enable the processor faults so that any issues that may arise due to wrong access of stack or changing from handler to thread mode etc can be caught
	enable_processor_faults();

	// Initialized the scheduler task by giving value to MSP register
	init_sched_stack(SCHED_STACK_START);

	// Create dummy stack SF1 and SF2 to initialize the stacks of each task
	init_task_stack();

	//Initialize LED peripheral
	led_init_all();

	// Configure and start the systick timer
	init_systick_timer(TICK_HZ);

	// Until this point stack pointer is MSP

	//to run a task handler, stack pointer or sp needs to be changed to PSP and only then task handler should be run
	switch_sp_to_PSP();

	// Run first task
	task1_handler();

	while(1);
}

//Task declarations
void task1_handler(void)
{
	while(1)
	{
		led_on(LED_GREEN);
		task_delay(1000); //1000 ms - ticks for 1 second
		led_off(LED_GREEN);
		task_delay(1000);
	}
}

void task2_handler(void)
{
	while(1)
	{
		led_on(LED_ORANGE);
		task_delay(500);
		led_off(LED_ORANGE);
		task_delay(500);
	}
}

void task3_handler(void)
{
	while(1)
	{
		led_on(LED_RED);
		task_delay(250);
		led_off(LED_RED);
		task_delay(250);
	}
}

void task4_handler(void)
{
	while(1)
	{
		led_on(LED_BLUE);
		task_delay(125);
		led_off(LED_BLUE);
		task_delay(125);
	}
}

void idle_task(void)
{
	while(1)
	{

	}
}

void init_systick_timer(uint32_t tick_hz)
{
	uint32_t count_value = (SYSTICK_TIM_CLK/tick_hz) - 1;

	uint32_t *pSRVR = (uint32_t*)0xE000E014;

	//Clear the first 24 bits - reload value
	*pSRVR &= ~(0x00FFFFFF);

	//Set the reload value
	*pSRVR |= count_value;

	//Settings
	uint32_t *pSCSR = (uint32_t*)0xE000E010;

	//Set first 3 bits to 1
	*pSCSR &= ~((1 << 0) | (1 << 1) | (1 << 2));
	*pSCSR |= ((1 << 1) | (1 << 2));

	//Enable the timer
	*pSCSR |= (1 << 0);


}

__attribute__((naked)) void init_sched_stack(uint32_t sched_top_of_stack_addr)
{
	__asm volatile("MSR MSP ,%0" : : "r" (sched_top_of_stack_addr) : );
	__asm volatile("BX LR"); //PC = LR link register contains return address
}

void update_next_task(void)
{
	uint8_t current_running_task =  current_task;

	do
	{
		current_task++;
		current_task %= MAX_TASKS; //so that it never exceeds max_tasks - 1

		// that means counter returned to current running task which happens only if all tasks are blocked
		if(current_task == current_running_task)
		{
			current_task = 0;
			break;
		}

	} while((current_task == 0) || (user_tasks[current_task].state == TASK_BLOCKED));

#ifdef PRIORITY_MOD
		if((current_task != PRIORITY_TASK) && (user_tasks[PRIORITY_TASK].state == TASK_READY))
		{
			current_task = PRIORITY_TASK;
		}
#endif

}

void update_psp_value_of_task(uint32_t current_psp_value)
{
	user_tasks[current_task].psp_value = current_psp_value;
}

#ifdef SYSTICK_HANDLER_AS_SCHEDULER
__attribute__((naked)) void SysTick_Handler(void)
{

	/** Save the context of current task **/

	// Get the current task PSP
	__asm volatile ("MRS R0, PSP"); // stores special register PSP current value to general register R0.

	// Store the values of R4-R11 (the rest are stored during stacking by processor) to current task's stack
	__asm volatile ("STMDB R0!, {R4-R11}"); //store to memory decrement before

	__asm volatile ("PUSH {LR}");
	// Update current task PSP
	__asm volatile("BL update_psp_value_of_task"); // The current R0 value will be passed as argument to this function. As R0 value is being updated as R4-R11 are written to it, R0 is the latest PSP value. we are saving it into our global array that maintains PSP

	/** Retrieve the context of next task **/

	// Decide what will be the next task
	__asm volatile ("BL update_next_task");

	// Get the past PSP value of next task
	__asm volatile ("BL get_current_psp_value"); //result stored in R0

	// Using PSP vaue retrieve R4-R11 for the next stack. Other registers will retrieved during unstacking by the processor
	__asm volatile ("LDMIA R0!, {R4-R11}"); //getting data from memory to registers so Load instruction increment after

	// Update PSP register to hold next task's stack pointer address and exit. Now R0 holds next task PSP
	__asm volatile ("MSR PSP, R0");

	__asm volatile ("POP {LR}");

	__asm volatile ("BX LR");

}
#endif

void update_global_tick_count()
{
	g_tick_count++;
}

void unblock_tasks()
{
	for(int i = 1; i < MAX_TASKS; i++)
	{
		if(user_tasks[i].state != TASK_READY)
		{
			if(user_tasks[i].block_count == g_tick_count)
			{
				user_tasks[i].state = TASK_READY;
			}
		}
	}
}

void SysTick_Handler(void)
{
	// Update global tick count
	update_global_tick_count();

	// Unblock any tasks whose block count has reached
	unblock_tasks();

	// Pend the PendSV and exit
	//Set the 28th bit of Interrupt Control and State register for pending the PendSV
	uint32_t *pICSR = (uint32_t*) 0xE000ED04;
	*pICSR |= (1 << 28);

}

__attribute__((naked)) void PendSV_Handler(void)
{
	/** Save the context of current task **/

	// Get the current task PSP
	__asm volatile ("MRS R0, PSP"); // stores special register PSP current value to general register R0.

	// Store the values of R4-R11 (the rest are stored during stacking by processor) to current task's stack
	__asm volatile ("STMDB R0!, {R4-R11}"); //store to memory decrement before

	__asm volatile ("PUSH {LR}");
	// Update current task PSP
	__asm volatile("BL update_psp_value_of_task"); // The current R0 value will be passed as argument to this function. As R0 value is being updated as R4-R11 are written to it, R0 is the latest PSP value. we are saving it into our global array that maintains PSP

	/** Retrieve the context of next task **/

	// Decide what will be the next task
	__asm volatile ("BL update_next_task");

	// Get the past PSP value of next task
	__asm volatile ("BL get_current_psp_value"); //result stored in R0

	// Using PSP vaue retrieve R4-R11 for the next stack. Other registers will retrieved during unstacking by the processor
	__asm volatile ("LDMIA R0!, {R4-R11}"); //getting data from memory to registers so Load instruction increment after

	// Update PSP register to hold next task's stack pointer address and exit. Now R0 holds next task PSP
	__asm volatile ("MSR PSP, R0");

	__asm volatile ("POP {LR}");

	__asm volatile ("BX LR");
}

void init_task_stack(void)
{
	user_tasks[0].psp_value = IDLE_STACK_START;
	user_tasks[1].psp_value = T1_STACK_START;
	user_tasks[2].psp_value = T2_STACK_START;
	user_tasks[3].psp_value = T3_STACK_START;
	user_tasks[4].psp_value = T4_STACK_START;

	user_tasks[0].state = TASK_READY;
	user_tasks[1].state = TASK_READY;
	user_tasks[2].state = TASK_READY;
	user_tasks[3].state = TASK_READY;
	user_tasks[4].state = TASK_READY;

	user_tasks[0].task_handler = idle_task;
	user_tasks[1].task_handler = task1_handler;
	user_tasks[2].task_handler = task2_handler;
	user_tasks[3].task_handler = task3_handler;
	user_tasks[4].task_handler = task4_handler;



	uint32_t *pPSP;
	for(int i=0; i < MAX_TASKS; i++)
	{

		//Initialize pointer to PSP
		pPSP = (uint32_t*)user_tasks[i].psp_value; // pPSP should point to the address store in psp_of_tasks for each task

		//full descending stack in Cortex M4 so first subtract then add.
		pPSP--; //PSR
		*pPSP = 0x01000000; //Set T bit  (24th) to 1 - Only Thumb instructions can be executed - DUMMY XPSR

		pPSP--; //PC
		*pPSP = (uint32_t) user_tasks[i].task_handler; //address of the task_handler function

		pPSP--; //LR
		*pPSP = 0xFFFFFFFD;//EXC_RETURN (exception return) special value so that from handler mode, the return happens to thread mode that uses PSP and non-floating point state from PSP

		//Genral purpose regs [r0 to r12]
		for(int j=0; j<13; j++)
		{
			pPSP--;
			*pPSP = 0;
		}

		//Save PSP
		user_tasks[i].psp_value = (uint32_t)pPSP;

	}
}

void enable_processor_faults(void)
{
	uint32_t *pSHCSR = (uint32_t*)0xE000ED24;

	//Clear the 16, 17 and 18 bits
	*pSHCSR &= ~((1 << 16) | (1 << 17) | (1 << 18));

	//Set 16, 17 and 18 bits to enable mem fault , bus fault and usage fault
	*pSHCSR |= ((1 << 16) | (1 << 17) | (1 << 18));


}

uint32_t get_current_psp_value(void)
{
	return user_tasks[current_task].psp_value;
}

__attribute__((naked)) void switch_sp_to_PSP(void)
{
	// Initialize PSP register with task 1's PSP
	__asm volatile ("PUSH {LR}"); //Preserve the LR so that you can return to main
	__asm volatile ("BL get_current_psp_value"); //stores the returned value to R0
	__asm volatile ("MSR PSP, R0"); //store psp of current task in PSP register
	__asm volatile ("POP {LR}"); // retrieve the previously saved LR to return to main later

	// Using CONTROL register switch SP to PSP
	__asm volatile ("MOV R0, #0x02"); //SPSEL 2nd bit should be set to 1 in CONTROL register for PSP
	__asm volatile ("MSR CONTROL, R0"); //move R0 value to control register
	__asm volatile ("BX LR"); //  Return to main
}

void schedule_next_task()
{
	//Pend the PendSV to run context switch
	uint32_t *pICSR = (uint32_t*) 0xE000ED04;
	*pICSR |= (1 << 28);
}

void task_delay(uint32_t tick_count)
{
	// Disable interrupts as this is a user task updating a global variable
	DISABLE_INTERRUPTS();

	if(current_task) // IDLE task cannot be put into blocked state
	{
		uint64_t bc = g_tick_count + tick_count;
		if(bc > MAX_DELAY)
		{
			user_tasks[current_task].block_count = bc - MAX_DELAY;
		}
		else
		{
			user_tasks[current_task].block_count = bc;
		}
		user_tasks[current_task].state = TASK_BLOCKED;

		// Block the current task and then schedule the next task
		schedule_next_task();
	}

	// Enable interrupts before exiting
	ENABLE_INTERRUPTS();
}

void MemManage_Handler(void)
{
	printf("Exception: Mem Fault \n");
	while(1);
}
void BusFault_Handler(void)
{
	printf("Exception: Bus Fault \n");
	while(1);
}

void UsageFault_Handler(void)
{
	printf("Exception: Usage Fault \n");
	while(1);
}
